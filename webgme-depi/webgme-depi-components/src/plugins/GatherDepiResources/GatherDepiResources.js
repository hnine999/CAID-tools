/*globals define*/
/*eslint-env node, browser*/

/**
 * Generated by PluginGenerator 2.20.5 from webgme on Fri Dec 15 2023 14:47:42 GMT-0600 (Central Standard Time).
 * A plugin that inherits from the PluginBase. To see source code documentation about available
 * properties and methods visit %host%/docs/source/PluginBase.html.
 */

define([
    'text!./metadata.json',
    'plugin/PluginBase',
    'webgme-depi/CONSTANTS',
    'depi-node-client',
    'simple-git',
    'fs',
    'path'
], function (pluginMetadata, PluginBase, CONSTANTS, depiNodeClient, simpleGit, fs, path) {
    const TOOL_ID = 'webgme';
    const DEPI_HEARTBEAT_MS = 10000;
    const MAX_VERSION_SYNC_CHECKS = 60; // each call waits 1 second
    const { depiUtils } = depiNodeClient;
    const git = simpleGit();
    pluginMetadata = JSON.parse(pluginMetadata);

    function gitUrlToPath(url) {
        return url.replace(/[\\/:]/g, '_');
    }

    async function cloneAndPull(repoUrl, repoDirPath, versionOrBranch, logger) {
        let newClone = false;
        if (fs.existsSync(repoDirPath)) {
            logger.info('Repo', repoUrl, 'exists at', repoDirPath);
        } else {
            logger.info('Cloning repo', repoUrl, 'to', repoDirPath, '...');
            await git.clone(repoUrl, repoDirPath);
            newClone = true;
        }

        const repoGit = simpleGit({ baseDir: path.join(process.cwd(), repoDirPath) })
        if (newClone) {
            await repoGit.addConfig('user.name', 'webgmePlugin');
            await repoGit.addConfig('user.email', 'webgmePlugin@mail.com');
        }

        await repoGit.fetch();
        await repoGit.checkout(versionOrBranch);
        return repoGit;
    }

    /**
     * Initializes a new instance of GatherDepiResources.
     * @class
     * @augments {PluginBase}
     * @classdesc This class represents the plugin GatherDepiResources.
     * @constructor
     */
    function GatherDepiResources() {
        // Call base class' constructor.
        PluginBase.call(this);
        this.pluginMetadata = pluginMetadata;
    }

    /**
     * Metadata associated with the plugin. Contains id, name, version, description, icon, configStructure etc.
     * This is also available at the instance at this.pluginMetadata.
     * @type {object}
     */
    GatherDepiResources.metadata = pluginMetadata;

    // Prototypical inheritance from PluginBase.
    GatherDepiResources.prototype = Object.create(PluginBase.prototype);
    GatherDepiResources.prototype.constructor = GatherDepiResources;

    /**
     * Main function for the plugin to execute. This will perform the execution.
     * Notes:
     * - Always log with the provided logger.[error,warning,info,debug].
     * - Do NOT put any user interaction logic UI, etc. inside this method.
     * - callback always has to be called even if error happened.
     *
     * @param {function(Error|null, plugin.PluginResult)} callback - the result callback
     */
    GatherDepiResources.prototype.main = async function (callback) {
        const logOut = async () => {
            if (this.depiSession) {
                this.logger.info('Logging out from depi server.');
                clearInterval(this.depiHeartbeatIntervalId);
                await depiUtils.logOut(this.depiSession);
                this.depiSession = null;
            }
        }

        try {
            await this.doWork();
            await logOut();
            this.result.setSuccess(true);
            callback(null, this.result);
        } catch (err) {
            await logOut();
            this.logger.error(err);
            this.result.setSuccess(false);
            callback(err.message, this.result);
        }
    };

    GatherDepiResources.prototype.doWork = async function () {
        const depiNodes = await this.getDepiNodes(this.activeNode);
        this.logger.info('Number of nodes with depiId', depiNodes.length);

        // 1) Login with depi client
        const { url, project, token } = this.gmeConfig.webhooks.defaults.depi.options.depi;
        const [userName, password] = token.split(':'); // TODO: Actual token.

        this.logger.info('Connecting to depi server', url);
        this.depiSession = await depiUtils.logInDepiClient(url, project, userName, password);

        // Set heartbeat interval to keep connection alive..
        this.depiHeartbeatIntervalId = setInterval(async () => {
            this.logger.info('Heartbeat interval reached', DEPI_HEARTBEAT_MS, ' [ms]. Pinging depi-server...');
            await depiUtils.ping(this.depiSession);
            this.logger.info('Pong!')
        }, DEPI_HEARTBEAT_MS);

        // 2) getNodeDependencies and resolve repositories
        const { webgmeBaseUrl } = this.gmeConfig.webhooks.defaults.depi.options;
        const { projectId } = this.project;
        const resourceGroupUrl = `${webgmeBaseUrl}?project=${projectId}`;
        this.logger.info('ResourceGroupUrl:', resourceGroupUrl);

        const repositories = new Map();
        const fileEntries = [];
        const nodeResources = [];
        for (const node of depiNodes) {
            const { resource, links } = await this.getNodeDependencies(node, resourceGroupUrl);
            if (!resource) {
                this.logger.info('No resource for depi node [', this.core.getAttribute(node, 'name'), ']');
                continue;
            }

            this.logger.info('Resource found', JSON.stringify(resource), 'checking its dependencies');
            nodeResources.push(resource);
            links.forEach(({ target }) => {
                if (target.toolId !== 'git') {
                    this.logger.warn('Unsupported dependency tool-type, only git allowed', target.toolId);
                    return;
                }

                if (!target.url.endsWith('.py')) {
                    this.logger.warn('Unsupported dependency file-type, only .py allowed', target.url);
                    return;
                }

                repositories.set(target.resourceGroupUrl, target.resourceGroupVersion);
                fileEntries.push({
                    nodePath: resource.url,
                    filePath: target.url,
                    repositoryUrl: target.resourceGroupUrl,
                    version: target.resourceGroupVersion,
                });
            });
        }

        // 3) Download git repos and grab files
        for (const [repoUrl, version] of repositories) {
            const repoDirPath = gitUrlToPath(repoUrl);
            await cloneAndPull(repoUrl, repoDirPath, version, this.logger);
        }

        const lines = [];

        for (const { nodePath, filePath, repositoryUrl, version } of fileEntries.sort((a, b) => a.nodePath.localeCompare(b.nodePath))) {
            lines.push('#############################################################');
            lines.push(`# nodePath = ${nodePath}`);
            lines.push(`# filePath = ${filePath}`);
            lines.push(`# repositoryUrl = ${repositoryUrl}`);
            lines.push(`# version = ${version}`);
            lines.push('#############################################################');
            const absFilePath = path.join(process.cwd(), gitUrlToPath(repositoryUrl), filePath);
            const content = fs.readFileSync(absFilePath, 'utf-8');
            content.split('\n').forEach((line) => lines.push(line));
        }

        this.logger.info(lines.join('\n'));

        // 4) Upload results to other git-repo
        const config = this.getCurrentConfig();
        const { targetRepoUrl, targetRepoBranch, targetRepoUser, targetRepoPassword } = config;
        if (!targetRepoUrl) {
            this.logger.info('No target repository provided - will not upload results');
            return;
        }

        const repoDirPath = gitUrlToPath(targetRepoUrl);

        // FIXME: this is not great for security
        let repoUrlWithCredentials = targetRepoUrl.replace('http://', `http://${targetRepoUser}:${targetRepoPassword}@`);
        const gitRepo = await cloneAndPull(repoUrlWithCredentials, repoDirPath, targetRepoBranch, this.logger);

        const absDir = path.join(process.cwd(), repoDirPath);
        const fileName = `${this.core.getAttribute(this.activeNode, 'name')}.txt`;
        const fileUrl = `/${fileName}`;
        const absFilePath = path.join(absDir, fileName);
        fs.writeFileSync(absFilePath, lines.join('\n'));
        await gitRepo.add([fileName]);
        await gitRepo.commit(`WebGME plugin update of ${fileName}`);
        await gitRepo.push('origin', 'main');
        const resultVersion = await gitRepo.revparse('HEAD');

        // 5) Report/update results in depi
        // First update the top-level node to now point to the latest resources
        const topResourceRef = {
            toolId: TOOL_ID,
            resourceGroupUrl,
            url: this.core.getPath(this.activeNode) + '/',
        };

        const resourceGroupVersion = this.commitHash;
        const resourceGroupName = `webgme:${projectId.split('+')[1]}`;

        const toAdd = {
            resources: [],
            links: [],
        };

        const toRemove = {
            resources: [],
            links: [],
        };

        const { resource, links } = await depiUtils.getDependencies(this.depiSession, topResourceRef);
        let topLevelResource = null;

        if (!resource) {
            this.logger.info('Top-level resource node did NOT exist', topResourceRef.url);
            topLevelResource = {
                ...topResourceRef,
                name: this.core.getAttribute(this.activeNode, 'name'),
                id: this.core.getGuid(this.activeNode),
                resourceGroupName,
                resourceGroupVersion,
            }

            toAdd.resources.push(topLevelResource);
        } else {
            this.logger.info('Top-level resource node existed', topResourceRef.url);
            topLevelResource = resource;
        }

        links.forEach((link) => {
            if (!nodeResources.some(res => depiUtils.isSameResource(link.target, res))) {
                toRemove.links.push(link);
            }
        });

        nodeResources.forEach((res) => {
            if (!links.some(link => depiUtils.isSameResource(link.target, res))) {
                toAdd.links.push({ source: topLevelResource, target: res });
            }
        });

        const resultResource = await this.ensureDepiSyncedAndCheckIfResourceExist(
            targetRepoUrl, fileUrl, resultVersion);

        let linkToMarkAsClean = null;

        if (resultResource) {
            this.logger.info('Result file resource existed in depi', resultResource.url);
            const { links } = await depiUtils.getDependencies(this.depiSession, resultResource);
            const currentResultLink = links.find(({target}) => depiUtils.isSameResource(target, topLevelResource));
            if (!currentResultLink) {
                toAdd.links.push({ source: resultResource, target: topLevelResource });
            } else if (currentResultLink.dirty || currentResultLink.inferredDirtiness.length > 0) {
                linkToMarkAsClean = currentResultLink;
            }
        } else {
            this.logger.info('Result file resource did NOT EXIST in depi', fileUrl);
            const newRes = {
                name: fileName,
                id: fileUrl,
                url: fileUrl,
                toolId: 'git',
                resourceGroupName: targetRepoUrl.split('/').pop(),
                resourceGroupUrl: targetRepoUrl,
                resourceGroupVersion: resultVersion,
            };

            toAdd.links.push({ source: newRes, target: topLevelResource });
        }

        if (toAdd.resources.length + toAdd.links.length > 0) {
            if (toAdd.resources.length > 0) {
                await depiUtils.addResourcesToBlackboard(this.depiSession, toAdd.resources);
            }

            for (const { source, target } of toAdd.links) {
                await depiUtils.addLinkToBlackboard(this.depiSession, source, target);
            }

            await depiUtils.saveBlackboard(this.depiSession);
            this.logger.info('Saved Blackboard with, resources:', toAdd.resources.length, 'and links:', toAdd.links.length);
        } else {
            this.logger.info('No new resources or links added to depi.');
        }

        if (toRemove.links.length > 0) {
            await depiUtils.deleteEntriesFromDepi(this.depiSession, toRemove);
            this.logger.info('Removed old depi-links:', toRemove.links.length);
        }

        if (linkToMarkAsClean) {
            this.logger.info('Marking existing link as totally clean.');
            await depiUtils.markAllClean(this.depiSession, [linkToMarkAsClean], () => {});
        }
    };

    GatherDepiResources.prototype.getDepiNodes = async function (rootNode) {
        const nodes = [];
        const core = this.core;

        await core.traverse(rootNode, { excludeRoot: true }, (node, done) => {
            if (core.getAttributeMeta(node, CONSTANTS.DEPI_ID_ATTRIBUTE)) {
                nodes.push(node);
            }

            done();
        });

        return nodes;
    };

    GatherDepiResources.prototype.ensureDepiSyncedAndCheckIfResourceExist = async function (targetRepoUrl, filePath, version) {
        let resourceGroups = await depiUtils.getResourceGroups(this.depiSession);
        let rg = resourceGroups.find(({ url }) => url === targetRepoUrl);

        if (!rg) {
            this.logger.info('Target repo did NOT exist in depi ..', targetRepoUrl);
            return null;
        }

        this.logger.info('Target repo exists in depi at:', targetRepoUrl);
        function sleep() {
            return new Promise(resolve => setTimeout(resolve, 1000));
        }

        let cnt = MAX_VERSION_SYNC_CHECKS; // 60 * 1000 ms -> 60s

        while (cnt) {
            if (rg.version === version) {
                this.logger.info('Version match! Checking for resource at', filePath);
                const resourcePattern = {
                    toolId: 'git',
                    resourceGroupUrl: targetRepoUrl,
                    urlPattern: filePath,
                };

                const resources = await depiUtils.getResources(this.depiSession, [resourcePattern]);
                if (resources.length === 1) {
                    return resources.pop();
                }

                return null;
            } else {
                this.logger.info('Version does not match[', rg.version, ']. Will try', cnt, 'more times..');
            }

            await sleep();
            resourceGroups = await depiUtils.getResourceGroups(this.depiSession);
            rg = resourceGroups.find(({ url }) => url === targetRepoUrl);
            cnt -= 1;
        }

        if (cnt === 0) {
            throw new Error(`Could not find new version ${version} of target-repo after ${MAX_VERSION_SYNC_CHECKS} [s]`);
        }
    };

    GatherDepiResources.prototype.getNodeDependencies = async function (node, resourceGroupUrl) {
        // 1. Get the url of all bases
        let base = node;
        const resourcePatterns = [];
        while (base) {
            resourcePatterns.push({
                toolId: TOOL_ID,
                resourceGroupUrl,
                urlPattern: this.core.getPath(base) + '/',
            });

            base = this.core.getBase(base);
        }

        // 2. Call out to get the resources of all bases.
        const resources = await depiUtils.getResources(this.depiSession, resourcePatterns);

        if (resources.length === 0) {
            return { resource: null, links: [] };
        }

        let resource = null;
        for (const resourceRef of resourcePatterns) {
            resource = resources.find(r => r.url === resourceRef.urlPattern)
            if (resource) {
                break;
            }
        }

        if (!resource) {
            return { resource: null, links: [] };
        }

        // 3. For the first match among bases - get direct dependencies
        const result = await depiUtils.getDependencies(this.depiSession, resource);
        const isDirty = result.links.some(link => link.dirty || link.inferredDirtiness.length > 0);
        if (isDirty) {
            this.logger.info('Has dirty dependencies');
            // After the run we probably want to clean up any direct dirtiness.
        }

        return result;
    }

    return GatherDepiResources;
});
